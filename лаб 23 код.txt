#include <stdio.h>
#include <stdlib.h>


typedef struct tree
{
    int v; // value
    struct tree *l;
    struct tree *r;
    struct tree *p;
    
} tree;

tree* new_tree(tree *root, int x)
{
    root = malloc(sizeof(tree));
    root->v = x;
    root->l = NULL; 
    root->r = NULL;
    root->p = NULL;
    return root;
}

tree* search(tree *root, int value)
{
    if (root == NULL) return NULL;
    if (root->v == value) return root;
    if (value < root->v) return search(root->l, value);
    else return search(root->r, value);
}


tree *add_node(tree *root, int value)
{
    tree *newnode = root;
    tree *parent = NULL;
    tree *tmp = malloc(sizeof(tree)); // выделение памяти под узел дерева
    tmp->v = value; // присваивание значения ячейке
    if (search(root, value) != NULL) {
        printf(" данная вершина уже существует\n");
        return 0;
    }
    while (newnode != NULL) { 
        parent = newnode;
        if (value < newnode->v) {
            newnode = newnode->l;
        } else {
            newnode = newnode->r;
        }
    }
    tmp->p = parent;
    tmp->l = NULL;
    tmp->r = NULL;
    if (value < parent->v) {
        parent->l = tmp;
    } else {
        parent->r = tmp;
    }
    return root;
}



tree* min_value(tree *root)
{
    while (root->l != NULL) root = root->l;
    return root;
}

tree* max_value(tree *root)
{
    while (root->r != NULL) root = root->r;
    return root;
}


tree *del_node(tree **root, int value)
{
    tree *del = NULL, *m = NULL;
    if (search(*root, value) == NULL) {
        printf(" данной вершины не существует\n");
        return 0;
    }
    del = search(*root, value); // поиск удаляемого узла по ключу
// 1 случай
    if ((del->l == NULL) && (del->r == NULL))
    {
        if (*root == del) {
            free(*root);
            *root = NULL;
            return 0;
        }
        m = del->p; // m == null
        if (del == m->r) m->r == NULL;
        else m->l == NULL;
        if (del->p->l == del) {
            free(del);
            del->p->l = NULL;
        }
        if (del->p->r == del) {
            free(del);
            del->p->r = NULL;
        }
        return 0;
    }
// 2 случай, 1 вариант - поддерево справа
    if ((del->l == NULL) && (del->r != NULL)) {
        m = del;
        del = min_value(del->r);
        m->v = del->v;
        if (del->p->l == del) {
            free(del);
            del->p->l = NULL;
        }
        if (del->p->r == del) {
            free(del);
            del->p->r = NULL;
        }
        return 0;
    }
// 2 случай, поддерево слева
    if ((del->l != NULL) && (del->r == NULL)) {
        m = del;
        del = max_value(del->l);
        m->v = del->v;
        if (del->p->l == del) {
            free(del);
            del->p->l = NULL;
            return 0;
        }
        if (del->p->r == del) {
            free(del);
            del->p->r = NULL;
            return 0;
        }
        return 0;
    }
// 3 случай
    if ((del->l != NULL) && (del->r != NULL)) {
        m = del;
        del = min_value(del->r);
        m->v = del->v;
        if (del->p->l == del) {
            free(del);
            del->p->l = NULL;
        }
        if (del->p->r == del) {
            free(del);
            del->p->r = NULL;
        }
        return 0;
    }
    return 0;
}




void draw_tree_side(tree *root, int n)
{
    if (root->l != NULL) draw_tree_side(root->l, n + 2);
    for (int i = 0; i < n; ++i) printf("  ");
    printf("%d\n", root->v);
    if (root->r) draw_tree_side(root->r, n + 2);
}

int maxDepth(tree *temp)
{
  if(temp == NULL)
  return 0;

 else
{
 int lchild = maxDepth(temp->l);
 int rchild = maxDepth(temp->r);

 if(lchild <= rchild)
 return rchild+1;

 else
  return lchild+1;

 }
 }
 
 void free_all(tree *root) {

    if(root == NULL)
    {
        return;
    }

    del_node(&root, root->v);
    free_all(root);


}

int main(void)
{
    char command;
    int x = 0, n = 0;
    printf("Введите число вершин: ");
    scanf("%d", &n);
    
    while (n == 0) {
        printf("введите число не равное 0\n");
        scanf("%d", &n);
    }
    
    printf("Введите значение вершин: ");
    scanf("%d", &x);
    int head = x;
    tree *root = new_tree(root, x);
    for (int q = 1; q < n; ++q) {
        scanf("%d", &x);
        add_node(root, x);
    }
    draw_tree_side(root, 1);
    
    printf("введите: \n(a) чтобы добавить вершину \n(d) чтобы удалить вершину \n(p) чтобы изобразить дерево\n(h) чтобы узнать глубину\n(e) чтобы выйти\n");
    do
    {
        scanf("%c", &command);
    
        if(command == 'a') {
            int num;
            printf("значение:");
            scanf("%d", &num);
            add_node(root , num);
            
            continue;
        }
        
        if(command == 'd') {
            int num;
            printf("значение:");
            scanf("%d", &num);
            del_node(&root, num);
            
            continue;
        }
        
        if(command == 'p') {
            draw_tree_side(root, 1);
            continue;
        }
        
        if(command == 'h') {
            int h = 0;
            h = maxDepth(root);
            printf("глубина дерева равна %d \n", h);
            continue;
        }
        
        
        
    }while(command != 'e');
   
    printf("выход\n");
    free_all(root);
    return 0;
}